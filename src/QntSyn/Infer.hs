module QntSyn.Infer where

import Data.Bifunctor
import Data.Functor
import Data.List
import Control.Monad.RWS.Lazy
import Control.Monad.Except
import Control.Monad.State
import Control.Monad.Writer
import qualified Data.Map as M
import qualified Data.Set as S
import Data.Maybe
import QntSyn

either' e l r = either l r e

secondM :: (Monad m) => (a -> m b) -> (c, a) -> m (c, b)
secondM f (x, y) = f y >>= \y' -> pure (x, y')

-- |The errors which can occur during type inference.
data TypeError = UnknownIdentError Identifier
               | InfiniteTypeError Type Type
               | CannotUnifyError  Type Type
  deriving (Show)

-- |The constraints which can be generated by the 'infer' function, to be
-- later solved.
data Constraint = Equality Type Type
  deriving (Show)

-- Constaint generation {{{

type TypeEnv = M.Map Identifier TyScheme

-- |The monad within which constraint generation runs. This is an RWS
-- (reader/writer/state) monad, with a read-only typing environment; a
-- writable list of constraints; and a integer state representing the
-- number of instantiated unification variables (to prevent conflicts).
-- It also contains an 'Except' monad in the stack for error reporting.
type Infer a =
  RWST
    TypeEnv             -- Typing environment
    [Constraint]        -- Generated constraints
    Integer             -- Number of type vars
    (Except TypeError)  -- The exception monad for error handling
    a

-- Small wrapper for runnning an Infer monad given a typing environment.
runInfer :: Infer a -> TypeEnv -> Either TypeError (a, [Constraint])
runInfer x env =
  case runExcept $ runRWST x env 0 of
    Left e -> Left e
    Right (y, _, cs) -> Right (y, cs)

-- |Generates a new unification variable.
fresh :: Infer Type
fresh = get >>= \c -> TypeVariable c <$ put (c+1)

-- |Instantiates a TyScheme with fresh unification variables and return
-- the resulting Type.
instantiate :: TyScheme -> Infer Type
instantiate (TyScheme vs t) = foldM f t vs
  where f t' v' = fresh <&> \tv -> replace v' tv t'
        replace i tn t'@(TypeVariable j)
          | i == j = tn
          | otherwise = t'
        replace i tn (TypeApplication t1 t2) = TypeApplication (replace i tn t1) (replace i tn t2)
        replace i tn t' = t'

-- |Looks up the given identifier in the typing environment, throwing
-- an appropriate 'TypeError' if it does not exist.
envLookup :: String -> Infer TyScheme
envLookup x = ask >>= maybe (throwError $ UnknownIdentError x) pure . M.lookup x

-- |Given a type, attempts to generalise it to a TyScheme by identifying
-- all type variables greater than or equal to the given limit.
generalise :: Integer -> Type -> TyScheme
generalise lim t = TyScheme (findVars t) t
  where
    findVars (TypeVariable i)
      | i < lim   = S.empty
      | otherwise = S.singleton i
    findVars (TypeApplication t0 t1) = S.union (findVars t0) (findVars t1)
    findVars t = S.empty

-- |The main type inferrence function. Given an expression and initial
-- environment, returns the type of the expression, as well as
-- (indirectly, via the 'Infer' monad) a list of constraints to solve.
infer :: Expr -> Infer Type

infer (ExprIdent x) = envLookup x >>= instantiate

infer (ExprApplication f x) =
  infer f >>= \tf ->
  infer x >>= \tx ->
  fresh >>= \tr ->
  tell [Equality tf (typeOp "->" tx tr)] *>
  return tr

infer (ExprNatLit x) = pure $ TypeConcrete "Nat"

infer (ExprLambda x y) =
  fresh >>= \tx ->
  local
    (M.insert x $ TyScheme S.empty tx)
    (typeOp "->" tx <$> infer y)

-- FIXME: For now, we basically treat this like a letrec - eventually we
-- should split these into groups of mutually recursive bindings.
infer (ExprLet xs inExpr) =
  inferBindingGroup xs >>= \bindsEnv ->
  local
    (M.union bindsEnv)
    (infer inExpr)


-- TODO
infer (ExprCase x ys) = undefined

inferBindingGroup :: [(Identifier, Expr)] -> Infer TypeEnv
inferBindingGroup bs =
      -- Instantiates a fresh simple (monomorphic) type for an
      -- identifier into a type environment.
  let extendEnvTmp :: TypeEnv -> Identifier -> Infer TypeEnv
      extendEnvTmp env name = fresh <&> \tv -> M.insert name (TyScheme S.empty tv) env

      -- Extends a type environment from a tuple of identifier and type
      -- scheme.
      extendEnv :: TypeEnv -> (Identifier, TyScheme) -> TypeEnv
      extendEnv env (name, scheme) = M.insert name scheme env

      -- Given a TypeEnv (where all schemes must be monotypes) and a
      -- list of type associations, generates equality constraints for
      -- corresponding names
      genEqualities :: TypeEnv -> [(Identifier, Type)] -> [Constraint]
      genEqualities env ts = ts <&> \(n, t0) -> case env M.! n of { TyScheme _ t1 -> Equality t0 t1 }

      -- The list of names of bindings in the group.
      names = fst <$> bs
  in
    -- We need to get the current type variable index to act as a
    -- "limit" later; type variables after this index will be included
    -- in the generalisation of bindings in the group.
    get >>= \lim ->

    -- envTmp is the temporary environment, with simple types
    -- instantiated for all bindings in the group.
    ask >>= (\e -> foldM extendEnvTmp e names) >>= \envTmp ->

    get >>= \curTyVar ->

    -- Infer the type of each binding with this temporary environment
    either'
      (runExcept $ runRWST (secondM infer `mapM` bs) envTmp curTyVar)
      throwError $

    -- xs is a list of (name, type) tuples; cs is the set of constraints
    -- to be solved
    \(xs, _, cs) ->

    -- Generate additional equalities between the auto-generated types
    -- and the inferred types
    let cs' = cs ++ genEqualities envTmp xs in

    -- Attempt to solve the constraints
    either'
      (runSolve solve cs')
      throwError $

    -- subs is a set of substitutions to apply to inferred types in xs
    -- cs' is a list of constraints which could not be solved, which
    -- should be pushed "up" into this inference monad
    \(_, subs, csLeft) ->

    -- Push the residual constraints into this monad
    tell csLeft *>

    -- Apply the substitutions to the inferred types, then generalise
    -- them with the limit we got earlier
    let xs' = second (generalise lim . subType subs) <$> xs
    in pure $ foldl' extendEnv M.empty xs'



-- }}}

-- Constraint solving {{{

type Solve a = WriterT Subs (StateT [Constraint] (Except TypeError)) a

runSolve :: Solve a -> [Constraint] -> Either TypeError (a, Subs, [Constraint])
runSolve s cs = runExcept (runStateT (runWriterT s) cs) <&> (\((x, subs), cs') -> (x, subs, cs'))

newtype Subs = Subs (M.Map Integer Type)
  deriving (Show)

instance Semigroup Subs where
  Subs x <> y'@(Subs y) = Subs $ M.union (M.map (subType y') x) y

instance Monoid Subs where
  mempty = Subs M.empty

-- Utility functions {{{
subType :: Subs -> Type -> Type
subType (Subs subs) t@(TypeVariable i) = M.findWithDefault t i subs
subType subs (TypeApplication x y) = TypeApplication (subType subs x) (subType subs y)
subType subs t = t

subConstraint :: Subs -> Constraint -> Constraint
subConstraint s (Equality t0 t1) = Equality (subType s t0) (subType s t1)

applySubs :: Subs -> Solve ()
applySubs s =
  tell s *>
  get >>= put . fmap (subConstraint s)

addConstraint :: Constraint -> Solve ()
addConstraint c = get >>= put . (c:)
-- }}}

-- |The main constraint solving function. Attempts to solve the set of
-- constraints existing within the monad's state, removing them as it
-- does so, and writing resulting substiutions out via the monad's
-- writer.
solve :: Solve ()
solve =
  get >>= \cs ->
  if null cs
  then pure ()
  else (
    put (tail cs) *>
    solve' (head cs) >>= \x ->
    (if x
     then pure ()
     else put (tail cs ++ [head cs])) *>
    solve
  )

solve' :: Constraint -> Solve Bool
solve' (Equality t0 t1) = unify t0 t1

-- |Attempts to unify the two given types within the constraint solver
-- monad. Returns whether or not it was successful; if true, then the
-- associated constraint should be considered solved, and hence removed
-- from the list.
unify :: Type -> Type -> Solve Bool

unify (TypeConcrete x) (TypeConcrete y) = pure (x == y)

unify (TypeVariable x) (TypeVariable y)
  | x == y = pure True
  | otherwise = applySubs (Subs $ M.singleton x (TypeVariable y)) $> True

unify x y@(TypeVariable _) = unify y x

unify x@(TypeVariable x') y
  | y `contains` x' = throwError $ InfiniteTypeError x y
  | otherwise = applySubs (Subs $ M.singleton x' y) $> True

unify (TypeApplication x y) (TypeApplication x' y') =
  addConstraint (Equality x x') *>
  addConstraint (Equality y y') $>
  True

unify x y = throwError $ CannotUnifyError x y

contains :: Type -> Integer -> Bool
(TypeApplication a b) `contains` i = a `contains` i || b `contains` i
(TypeVariable j) `contains` i = i == j
_ `contains` _ = False

-- }}}
