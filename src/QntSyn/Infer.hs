module QntSyn.Infer where

import Data.Functor
import Control.Monad.RWS.Lazy
import Control.Monad.Except
import Control.Monad.State
import Control.Monad.Writer
import qualified Data.Map as M
import qualified Data.Set as S
import Data.Maybe
import QntSyn

-- |The errors which can occur during type inference.
data TypeError = UnknownIdentError Identifier
  deriving (Show)

-- |The constraints which can be generated by the 'infer' function, to be
-- later solved.
data Constraint = Equality Type Type
  deriving (Show)

-- Constaint generation {{{

-- |The monad within which constraint generation runs. This is an RWS
-- (reader/writer/state) monad, with a read-only typing environment; a
-- writable list of constraints; and a integer state representing the
-- number of instantiated unification variables (to prevent conflicts).
-- It also contains an 'Except' monad in the stack for error reporting.
type Infer a =
  RWST
    (M.Map Identifier TyScheme)  -- Typing environment
    [Constraint]                 -- Generated constraints
    Integer                      -- Number of type vars
    (Except TypeError)           -- The exception monad for error handling
    a

-- |Generates a new unification variable.
fresh :: Infer Type
fresh = get >>= \c -> TypeVariable c <$ put (c+1)

-- |Instantiates a TyScheme with fresh unification variables and return
-- the resulting Type.
instantiate :: TyScheme -> Infer Type
instantiate (TyScheme vs t) = foldM f t vs
  where f t' v' = fresh <&> \tv -> replace v' tv t'
        replace i tn t'@(TypeVariable j)
          | i == j = tn
          | otherwise = t'
        replace i tn (TypeApplication t1 t2) = TypeApplication (replace i tn t1) (replace i tn t2)
        replace i tn t' = t'

-- |Looks up the given identifier in the typing environment, throwing
-- an appropriate 'TypeError' if it does not exist.
envLookup :: String -> Infer TyScheme
envLookup x = ask >>= maybe (throwError $ UnknownIdentError x) pure . M.lookup x

-- |Given a type, attempts to generalise it to a TyScheme by identifying
-- all type variables not in the given set.
generalise :: Type -> S.Set Integer -> TyScheme
generalise t vs = TyScheme (findVars t vs) t
  where
    findVars (TypeVariable i) vs
      | i `S.member` vs = S.empty
      | otherwise   = S.singleton i
    findVars (TypeApplication t0 t1) vs = S.union (findVars t0 vs) (findVars t1 vs)
    findVars t vs = S.empty

-- |The main type inferrence function. Given an expression and initial
-- environment, returns the type of the expression, as well as
-- (indirectly, via the 'Infer' monad) a list of constraints to solve.
infer :: Expr -> Infer Type

infer (ExprIdent x) = envLookup x >>= instantiate

infer (ExprApplication f x) =
  infer f >>= \tf ->
  infer x >>= \tx ->
  fresh >>= \tr ->
  tell [Equality tf (typeOp "->" tx tr)] *>
  return tr

infer (ExprNatLit x) = pure $ TypeConcrete "Nat"

infer (ExprLambda x y) =
  fresh >>= \tx ->
  local
    (M.insert x $ TyScheme S.empty tx)
    (typeOp "->" tx <$> infer y)

-- TODO
infer (ExprLet xs y) = undefined

-- TODO
infer (ExprCase x ys) = undefined

-- }}}

-- Constraint solving {{{

type Solve a = WriterT Subs (StateT [Constraint] (Except TypeError)) a

newtype Subs = Subs (M.Map Integer Type)
  deriving (Show)

instance Semigroup Subs where
  Subs x <> y'@(Subs y) = Subs $ M.union (M.map (subType y') x) y

instance Monoid Subs where
  mempty = Subs M.empty

-- Utility functions {{{
subType :: Subs -> Type -> Type
subType (Subs subs) t@(TypeVariable i) = M.findWithDefault t i subs
subType subs (TypeApplication x y) = TypeApplication (subType subs x) (subType subs y)
subType subs t = t

subConstraint :: Subs -> Constraint -> Constraint
subConstraint s (Equality t0 t1) = Equality (subType s t0) (subType s t1)

applySubs :: Subs -> Solve ()
applySubs s =
  tell s *>
  get >>= put . fmap (subConstraint s)

addConstraint :: Constraint -> Solve ()
addConstraint c = get >>= put . (c:)
-- }}}

-- |The main constraint solving function. Attempts to solve the set of
-- constraints existing within the monad's state, removing them as it
-- does so, and writing resulting substiutions out via the monad's
-- writer.
solve :: Solve ()
solve =
  get >>= \cs ->
  if null cs
  then pure ()
  else (
    put (tail cs) *>
    solve' (head cs) >>= \x ->
    (if x
     then pure ()
     else put (tail cs ++ [head cs])) *>
    solve
  )

solve' :: Constraint -> Solve Bool
solve' (Equality t0 t1) = unify t0 t1

-- |Attempts to unify the two given types within the constraint solver
-- monad. Returns whether or not it was successful; if true, then the
-- associated constraint should be considered solved, and hence removed
-- from the list.
unify :: Type -> Type -> Solve Bool

unify (TypeConcrete x) (TypeConcrete y) = pure (x == y)

unify (TypeVariable x) (TypeVariable y)
  | x == y = pure True
  | otherwise = applySubs (Subs $ M.singleton x (TypeVariable y)) $> True

unify x y@(TypeVariable _) = unify y x

unify (TypeVariable x) y
  | y `contains` x = error "Cannot solve the infinite type"
  | otherwise = applySubs (Subs $ M.singleton x y) $> True

unify (TypeApplication x y) (TypeApplication x' y') =
  addConstraint (Equality x x') *>
  addConstraint (Equality y y') $>
  True

contains :: Type -> Integer -> Bool
(TypeApplication a b) `contains` i = a `contains` i || b `contains` i
(TypeVariable j) `contains` i = i == j
_ `contains` _ = False

-- }}}
