module QntSyn.Infer where

import Control.Monad.RWS.Lazy
import Control.Monad.Except
import qualified Data.Map as M
import Data.Maybe
import QntSyn

-- |The errors which can occur during type inference.
data TypeError = UnknownIdentError Identifier
  deriving (Show)

-- |The constraints which can be generated by the 'infer' function, to be
-- later solved.
data Constraint = Equality Type Type
  deriving (Show)

-- |The monad within which constraint generation runs. This is an RWS
-- (reader/writer/state) monad, with a read-only typing environment; a
-- writable list of constraints; and a integer state representing the
-- number of instantiated unification variables (to prevent conflicts).
-- It also contains an 'Except' monad in the stack for error reporting.
type Infer a =
  RWST
    (M.Map Identifier Type)  -- Typing environment
    [Constraint]             -- Generated constraints
    Integer                  -- Number of type vars
    (Except TypeError)       -- The exception monad for error handling
    a

-- |Generates a new unification variable.
fresh :: Infer Type
fresh = get >>= \c -> TypeUnification c <$ put (c+1)

-- |Looks up the given identifier in the typing environment, throwing
-- an appropriate 'TypeError' if it does not exist.
envLookup :: String -> Infer Type
envLookup x = ask >>= maybe (throwError $ UnknownIdentError x) pure . M.lookup x

-- |The main type inferrence function. Given an expression and initial
-- environment, returns the type of the expression, as well as
-- (indirectly, via the 'Infer' monad) a list of constraints to solve.
infer :: Expr -> Infer Type

infer (ExprIdent x) = envLookup x

infer (ExprApplication f x) =
  infer f >>= \tf ->
  infer x >>= \tx ->
  fresh >>= \tr ->
  tell [Equality tf (typeOp "->" tx tr)] *>
  return tr

infer (ExprNatLit x) = pure $ TypeConcrete "Nat"

infer (ExprLambda x y) =
  fresh >>= \tx ->
  local
    (M.insert x tx)
    (typeOp "->" tx <$> infer y)

infer (ExprLet xs y) =
      let -- Generates a fresh type variable for the given binding x and
          -- adds to to the environment
          genVar env x = (\t -> M.insert (fst x) t env) <$> fresh

          -- Generates an equality for the env type variable of a binding
          -- and its inferred type
          inferLet x =
            envLookup (fst x) >>= \t0 ->
            infer (snd x) >>= \t1 ->
            tell [Equality t0 t1]
      in
        ask >>= \env ->
        foldM genVar env xs >>= \env' ->
        local
          (const env')
          (inferLet `mapM_` xs *> infer y)

-- TODO
infer (ExprCase x ys) = undefined

type Substitution = M.Map Integer Type


solve :: [Constraint] -> Substitution -> Substitution
solve [] m = m
solve xs m =
  let solns = (\(Equality a b) -> unify a b) <$> xs
      idxSolns = zip [0..] solns
  in case filter (isJust . snd) idxSolns of
    (i,Just x):_ ->
        let m' = merge m x
            xs' = fmap (subConstraint x) $ take i xs ++ drop (i+1) xs
        in solve xs' m'
    _ -> error "couldn't solve :("

subConstraint :: Substitution -> Constraint -> Constraint
subConstraint subs (Equality t0 t1) = Equality (substitute subs t0) (substitute subs t1)

unify :: Type -> Type -> Maybe Substitution

unify (TypeConcrete a) (TypeConcrete b)
    | a == b = Just (M.empty)
    | otherwise = Nothing

unify (TypeUnification a) (TypeUnification b)
    | a == b = Just $ M.empty
    | otherwise = Just $ M.singleton a (TypeUnification b)

unify other (TypeUnification a) = unify (TypeUnification a) other

unify (TypeUnification a) other
    | contains a other = error "Cannot solve infinite type"
    | otherwise = Just $ M.singleton a other

unify (TypeApplication a b) (TypeApplication a' b') = 
    unify a a' >>= \subs0 ->
    unify b b' >>= \subs1 ->
    Just $ merge subs0 subs1

unify _ _ = Nothing

substitute :: Substitution -> Type -> Type

substitute subs (TypeUnification i)
    | M.member i subs = subs M.! i
    | otherwise = TypeUnification i

substitute subs (TypeApplication a b) = 
    TypeApplication (substitute subs a) (substitute subs b)
    
substitute sub x = x


contains :: Integer -> Type -> Bool
contains i (TypeApplication a b) = contains i a || contains i b
contains i (TypeUnification i') = i == i'
contains _ _ = False


merge :: Substitution -> Substitution -> Substitution
merge a b = M.union (M.map (substitute a) b) a
