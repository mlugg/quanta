module QntSyn.Infer where

import Data.Bifunctor
import Data.Functor
import Data.List
import Control.Monad.RWS.Lazy
import Control.Monad.Except
import Control.Monad.State
import Control.Monad.Writer
import qualified Data.Map as M
import qualified Data.Set as S
import Data.Maybe
import QntSyn

either' e l r = either l r e

firstM :: (Monad m) => (a -> m b) -> (a, c) -> m (b, c)
firstM f (x, y) = f x >>= \x' -> pure (x', y)

secondM :: (Monad m) => (a -> m b) -> (c, a) -> m (c, b)
secondM f (x, y) = f y >>= \y' -> pure (x, y')

unionAll :: (Ord k) => [M.Map k v] -> M.Map k v
unionAll (x:xs) = x `M.union` unionAll xs
unionAll [] = M.empty

mkMap :: (Ord k) => [(k, v)] -> M.Map k v
mkMap ((x, y):xs) = M.insert x y $ mkMap xs
mkMap [] = M.empty

-- |The errors which can occur during type inference.
data TypeError = UnknownIdentError Identifier
               | InfiniteTypeError Type Type
               | CannotUnifyError  Type Type
  deriving (Show)

-- |The constraints which can be generated by the 'infer' function, to be
-- later solved.
data Constraint = Equality Type Type
  deriving (Show)

-- Constaint generation {{{

type TypeEnv = M.Map Identifier TyScheme

data InferEnv = InferEnv
  { getTypeEnv :: TypeEnv
  , getConstrs :: M.Map Identifier ADTConstr -- Maps from constructor names to info about them
  }

-- |The monad within which constraint generation runs. This is an RWS
-- (reader/writer/state) monad, with a read-only typing environment; a
-- writable list of constraints; and a integer state representing the
-- number of instantiated unification variables (to prevent conflicts).
-- It also contains an 'Except' monad in the stack for error reporting.
type Infer a =
  RWST
    InferEnv            -- Typing environment
    [Constraint]        -- Generated constraints
    Integer             -- Number of type vars
    (Except TypeError)  -- The exception monad for error handling
    a

-- Small wrapper for runnning an Infer monad given a typing environment.
runInfer :: Infer a -> InferEnv -> Either TypeError (a, [Constraint])
runInfer x env =
  case runExcept $ runRWST x env 0 of
    Left e -> Left e
    Right (y, _, cs) -> Right (y, cs)

-- |Generates a new unification variable.
fresh :: Infer Type
fresh = get >>= \c -> TVariable c <$ put (c+1)

localTE :: (TypeEnv -> TypeEnv) -> Infer a -> Infer a
localTE f = local (\e -> e {getTypeEnv = f $ getTypeEnv e})

replace :: (M.Map Integer Type) -> Type -> Type
replace subs t'@(TVariable j) = fromMaybe t' (M.lookup j subs)
replace subs (TApplication t1 t2) = TApplication (replace subs t1) (replace subs t2)
replace subs t' = t'

-- |Instantiates a TyScheme with fresh unification variables and return
-- the resulting Type.
instantiate :: TyScheme -> Infer Type
instantiate (TyScheme vs t) =
  let vsl = S.toList vs in
  const fresh `mapM` vsl <&> \vs' ->
  replace (mkMap $ zip vsl vs') t

-- |Looks up the given identifier in the typing environment, throwing
-- an appropriate 'TypeError' if it does not exist.
envLookup :: String -> Infer TyScheme
envLookup x = ask >>= maybe (throwError $ UnknownIdentError x) pure . M.lookup x . getTypeEnv

-- |Given a type, attempts to generalise it to a TyScheme by identifying
-- all type variables greater than or equal to the given limit.
generalise :: Integer -> Type -> TyScheme
generalise lim t = TyScheme (findVars t) t
  where
    findVars (TVariable i)
      | i < lim   = S.empty
      | otherwise = S.singleton i
    findVars (TApplication t0 t1) = S.union (findVars t0) (findVars t1)
    findVars t = S.empty

-- |The main type inferrence function. Given an expression and initial
-- environment, returns the type of the expression, as well as
-- (indirectly, via the 'Infer' monad) a list of constraints to solve.
infer :: Expr -> Infer Type

infer (EIdent x) = envLookup x >>= instantiate

infer (EApplication f x) =
  infer f >>= \tf ->
  infer x >>= \tx ->
  fresh >>= \tr ->
  tell [Equality tf (typeOp "->" tx tr)] *>
  return tr

infer (ENatLit x) = pure $ TConcrete "Nat"

infer (ELambda x y) =
  fresh >>= \tx ->
  localTE
    (M.insert x $ TyScheme S.empty tx)
    (typeOp "->" tx <$> infer y)

-- FIXME: For now, we basically treat this like a letrec - eventually we
-- should split these into groups of mutually recursive bindings.
infer (ELet xs inExpr) =
  inferBindingGroup xs >>= \bindsEnv ->
  localTE
    (M.union bindsEnv)
    (infer inExpr)


-- TODO
infer (ECase x ys) =
  infer x >>= \tx ->
  firstM (inferPatTypes tx) `mapM` ys >>=
  mapM (\(env, expr) -> localTE (M.union env) (infer expr)) >>= \zs ->
  fresh >>= \t ->
  tell (Equality t <$> zs) $>
  t

-- Pattern matching {{{

-- TODO: Clean up this function, it's messy and slow
instantiateConstr :: ADTConstr
                  -> Infer (Type, [Type])

instantiateConstr (ADTConstr tname targs cargs) =
  const fresh `mapM` targs >>= \targs' ->
  let replaceAll t = replace (mkMap $ zip targs targs') t
      fullType = f $ reverse targs'
      f (x:xs) = TApplication (f xs) x
      f [] = TConcrete tname
  in pure (fullType, replaceAll <$> cargs)

inferPatTypes :: Type           -- The type of the expr being matched against
              -> Pattern        -- The pattern being matched against the expression
              -> Infer TypeEnv  -- The resulting environment within this match

inferPatTypes t (PIdent x) = pure $ M.singleton x (TyScheme S.empty t)

inferPatTypes t (PNatLit x) =
  tell [Equality t (TConcrete "Nat")] $>
  M.empty

inferPatTypes t (PConstr name args) =
  M.lookup name . getConstrs <$> ask >>=
  maybe
    (throwError $ UnknownIdentError name)
    pure >>= instantiateConstr >>= \(tname, cargs) ->
    if length cargs /= length args
    then throwError $ error "TODO: handle invalid number of constr params"
    else
      tell [Equality t $ tname] *>
      zipWithM inferPatTypes cargs args <&> unionAll -- TODO FIXME: Check for duplicated names!!!!

-- }}}

inferBindingGroup :: [(Identifier, Expr)] -> Infer TypeEnv
inferBindingGroup bs =
      -- Instantiates a fresh simple (monomorphic) type for an
      -- identifier into a type environment.
  let extendEnvTmp :: TypeEnv -> Identifier -> Infer TypeEnv
      extendEnvTmp env name = fresh <&> \tv -> M.insert name (TyScheme S.empty tv) env

      -- Extends a type environment from a tuple of identifier and type
      -- scheme.
      extendEnv :: TypeEnv -> (Identifier, TyScheme) -> TypeEnv
      extendEnv env (name, scheme) = M.insert name scheme env

      -- Given a TypeEnv (where all schemes must be monotypes) and a
      -- list of type associations, generates equality constraints for
      -- corresponding names
      genEqualities :: TypeEnv -> [(Identifier, Type)] -> [Constraint]
      genEqualities env ts = ts <&> \(n, t0) -> case env M.! n of { TyScheme _ t1 -> Equality t0 t1 }

      -- The list of names of bindings in the group.
      names = fst <$> bs
  in
    -- We need to get the current type variable index to act as a
    -- "limit" later; type variables after this index will be included
    -- in the generalisation of bindings in the group.
    get >>= \lim ->

    -- envTmp is the temporary environment, with simple types
    -- instantiated for all bindings in the group.
    ask >>= (
        \e  -> foldM extendEnvTmp (getTypeEnv e) names >>=
        \te -> pure $ e {getTypeEnv = te}) >>= \envTmp ->

    get >>= \curTyVar ->

    -- Infer the type of each binding with this temporary environment
    either'
      (runExcept $ runRWST (secondM infer `mapM` bs) envTmp curTyVar)
      throwError $

    -- xs is a list of (name, type) tuples; cs is the set of constraints
    -- to be solved
    \(xs, _, cs) ->

    -- Generate additional equalities between the auto-generated types
    -- and the inferred types
    let cs' = cs ++ genEqualities (getTypeEnv envTmp) xs in

    -- Attempt to solve the constraints
    either'
      (runSolve solve cs')
      throwError $

    -- subs is a set of substitutions to apply to inferred types in xs
    -- cs' is a list of constraints which could not be solved, which
    -- should be pushed "up" into this inference monad
    \(_, subs, csLeft) ->

    -- Push the residual constraints into this monad
    tell csLeft *>

    -- Apply the substitutions to the inferred types, then generalise
    -- them with the limit we got earlier
    let xs' = second (generalise lim . subType subs) <$> xs
    in pure $ foldl' extendEnv M.empty xs'



-- }}}

-- Constraint solving {{{

type Solve a = WriterT Subs (StateT [Constraint] (Except TypeError)) a

runSolve :: Solve a -> [Constraint] -> Either TypeError (a, Subs, [Constraint])
runSolve s cs = runExcept (runStateT (runWriterT s) cs) <&> (\((x, subs), cs') -> (x, subs, cs'))

newtype Subs = Subs (M.Map Integer Type)
  deriving (Show)

instance Semigroup Subs where
  Subs x <> y'@(Subs y) = Subs $ M.union (M.map (subType y') x) y

instance Monoid Subs where
  mempty = Subs M.empty

-- Utility functions {{{
subType :: Subs -> Type -> Type
subType (Subs subs) t@(TVariable i) = M.findWithDefault t i subs
subType subs (TApplication x y) = TApplication (subType subs x) (subType subs y)
subType subs t = t

subConstraint :: Subs -> Constraint -> Constraint
subConstraint s (Equality t0 t1) = Equality (subType s t0) (subType s t1)

applySubs :: Subs -> Solve ()
applySubs s =
  tell s *>
  get >>= put . fmap (subConstraint s)

addConstraint :: Constraint -> Solve ()
addConstraint c = get >>= put . (c:)
-- }}}

-- |The main constraint solving function. Attempts to solve the set of
-- constraints existing within the monad's state, removing them as it
-- does so, and writing resulting substiutions out via the monad's
-- writer.
solve :: Solve ()
solve =
  get >>= \cs ->
  if null cs
  then pure ()
  else (
    put (tail cs) *>
    solve' (head cs) >>= \x ->
    (if x
     then pure ()
     else put (tail cs ++ [head cs])) *>
    solve
  )

solve' :: Constraint -> Solve Bool
solve' (Equality t0 t1) = unify t0 t1

-- |Attempts to unify the two given types within the constraint solver
-- monad. Returns whether or not it was successful; if true, then the
-- associated constraint should be considered solved, and hence removed
-- from the list.
unify :: Type -> Type -> Solve Bool

unify (TConcrete x) (TConcrete y) = pure (x == y)

unify (TVariable x) (TVariable y)
  | x == y = pure True
  | otherwise = applySubs (Subs $ M.singleton x (TVariable y)) $> True

unify x y@(TVariable _) = unify y x

unify x@(TVariable x') y
  | y `contains` x' = throwError $ InfiniteTypeError x y
  | otherwise = applySubs (Subs $ M.singleton x' y) $> True

unify (TApplication x y) (TApplication x' y') =
  addConstraint (Equality x x') *>
  addConstraint (Equality y y') $>
  True

unify x y = throwError $ CannotUnifyError x y

contains :: Type -> Integer -> Bool
(TApplication a b) `contains` i = a `contains` i || b `contains` i
(TVariable j) `contains` i = i == j
_ `contains` _ = False

-- }}}
